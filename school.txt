HR question
  5、咱们招人的原因是什么
  6、咱们前端团队有多少人
  0、试用期 是否全薪
  1、社保等缴存比例
  2、多少薪
  3、房补饭补等
  4、上班时间、地点 是否双休
  
职业规划
  
离职原因
  在kid呆了快三年了， 想换一个环境

工作遇到的问题  如何解决的
  0、页面返回后的刷新问题
    如果只需要监听到这个事件 app内使用 app提供的pageshow方法
    如果刷新这个页面 使用worker 特性使页面没有cache 达到刷新的目的
  1、课程详情取消约课 500 日志大量飙升
      公司更换 cdn 供应商 供应商对500 的请求策略有8次重试造成
  2、安全组发现供需接口漏洞  xss 攻击修改 body
      网关使用Parameter 校验一家人  而供需组使用body 但是只校验了 操作人和学生的关系 没有token校验。
  3、ios 上自动执行focus()无法唤起键盘  非用户点击权限不够
      在用户点击搜索时隐藏一个input在按钮上 这样可以获得用户点击权限 成功唤起键盘
      该方法比较hack
最近在研究什么
  研究了一下 rem和px那个好

HTML&CSS：
	对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、
	Hack、CSS预处理器、CSS3、Flexbox、CSS Modules、Document flow、BFC、HTML5（离线 & 存储、Histoy,多媒体、WebGL\SVG\Canvas）；		
JavaScript：
    数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、
    内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、

其他：
    主流MVVM框架(React\Vue\Angular)、Hybrid App\React Native\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、
    重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；

记录一些知识点
手写bind 函数 https://github.com/Raynos/function-bind/blob/master/implementation.js
手写promise 
定时器为什么不准
let、const和var的区别 
闭包介绍和它的作用
数组去重、扁平化、柯里化 
回文字符串 
尾调用优化


- `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
- `Object.keys()`：返回对象自身的所有可枚举的属性的键名。

IOS UIWebView  Andriod  webkit 内核（4.4之前） Chromium 内核

CSRF  XSS
跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。



CommonJS AMD Module
  http://javascript.ruanyifeng.com/nodejs/module.html
  http://es6.ruanyifeng.com/#docs/module
  CommonJS 规范 运用于node js 每个文件都是模块使用时加载 require 时会读取 module.exports 属性
    所有代码都运行在模块作用域，不会污染全局作用域。
    模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
    模块加载的顺序，按照其在代码中出现的顺序。

    加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式。
    module {
      id: 模块的识别符，通常是带有绝对路径的模块文件名。
      filename: 模块的文件名，带有绝对路径。
      loaded: 返回一个布尔值，表示模块是否已经完成加载。
      parent: 返回一个对象，表示调用该模块的模块。
      children: 返回一个数组，表示该模块要用到的其他模块。
      exports 表示模块对外输出的值。
    }
    每个模块内部会直接写入 exports 对象等同于 var exports = module.exports;
      (注意事项 不能直接对 exports 赋值；如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。)
    require 读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。
      对于对此require同一模块 不会重新加载 输出的是缓存 -> require.cache 
      如果脚本/home/user/projects/foo.js执行了require('bar.js')命令，Node会依次搜索以下文件。
        /usr/local/lib/node/bar.js
        /home/user/projects/node_modules/bar.js
        /home/user/node_modules/bar.js
        /home/node_modules/bar.js
        /node_modules/bar.js
      这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。
  AMD 规范 运用于浏览器环境
    AMD规范则是非同步加载模块，允许指定回调函数。
    define 方法定义模块 也可以兼容 CommonJS 规范
  Module 语法
    ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
    export
      命令规定的是对外的接口 不能输出值或代表值的变量包括fn class 等.
      语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。
      export 可以位于模块任何位置 但必须在模块顶层  不能在块级作用域
        let m = 1
        export m  //报错
        export { m }
        export { m as ma}
        export var m = 1;
        function a() {}
        export a  //报错
    import
      命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。或者使用as关键字。
      命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
      命令具有提升效果，会提升到整个模块的头部，首先执行。(命令是编译阶段执行的，在代码运行之前。)
      命令是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。
        //main.js
        export let name = 'abc' 
        import { name } from './main.js'
        import { name as nameUSA } from './main.js'
      语句会执行所加载的模块，因此可以有下面的写法。
        import 'lodash'; //不输入任何信息 只执行模块
      如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
      整体加载，即用星号（*）指定一个对象
        //circle.js
        export function a(){}
        export function b(){}
        import * as circle from './circle';
        circle.a()
        circle.b()
        circle.a = 5 //报错 不允许对输出接口改写
    export default
      输出的是一个变量不是一个接口，实质是把输出的值赋值给 default（输出变量、fn、class）
      使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。
      为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出
        // export-default.js
        export default function () {
          console.log('foo');
        }
        import customName from './export-default';
        customName()

      export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。
        // modules.js
        function add(x, y) {
          return x * y;
        }
        export {add as default};
        // 等同于
        export default add;

        // app.js
        import { default as foo } from 'modules';
        // 等同于
        import foo from 'modules';
      可以和import 同时使用
        //lodash.js
        export default function (obj) {}
        export function each(obj, iterator, context) {}
        export { each as forEach };
        import _, { each, forEach } from 'lodash';
    export 与 import 的复合写法
      如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
      但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。
        export { foo, bar } from 'my_module';
        // 可以简单理解为
        import { foo, bar } from 'my_module';
        export { foo, bar };
        // export default
        export { default } from 'foo';



Vue
  style scoped  可以这样使作用于子组件
  .a >>> .b { /* ... */ }


1、捕获和冒泡
  被点击节点 先绑定先执行
  先捕获从上到下
  后冒泡从下到上


S 95≤得分≤100
  工作成果显著超出目标预期/岗位要求，有重大突破或创新

A 90≤得分＜95
  工作成果均超出目标预期/岗位要求，有亮点

B+ 85≤得分<90
  工作成果整体达标，有部分超出目标预期/岗位要求，有亮点
B 75≤得分<85
  工作成果整体达标，完全达到目标预期/岗位要求
B- 70≤得分<75
  工作成果整体达标，有部分达到目标预期/岗位要求，需要提高

C 60≤得分<70
  工作成果未达到目标预期/岗位要求，存在一些差距，存在一定改进空间
D 0≤得分<60
  工作成果未达到目标预期/岗位要求，存在明显差距