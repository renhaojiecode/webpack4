后续准备
  稳定性建设：
    1、机器备份 页面404 在阿里云和腾讯云两套服务器 如果请求资源时服务器访问资源404就切换到别的资源
    2、页面静态资源404 在页面统一监听 onerror 如果是静态资源404就切换备份静态资源地址

  性能优化：
    1、静态资源多域名部署、可以解决
      首先是使用不同域名可以再访问资源时不携带cookie 加快访问速度，
      浏览器对于同域名资源访问数量的限制，
      同时可以对这些域名做DNS预解析，
    2、非首页展示资源 懒加载
    3、开启 gzip压缩  content-encoding: gzip
    4、http 升级 1.1可以进行长连接 Connection: keep-alive； HTTP2.0 可以进行多路复用
    5、开启缓存 Cache-Control 强缓存  If-None-Match/E-tag 协商缓存
    6、代码层面可以：
      js外链资源放在body底部
      修改样式是最好 定义class进行修改 避免多次渲染
      缓存一些获取的值 比如offsetTop等
      采用虚拟dom
  服务端渲染：ssr   框架 nuxt.js
    // PC站 项目中的高峰期 使用ssr渲染
    更快 一个方面是 服务器内网访问没有带宽限制速度快，并且可以进行缓存
    1、两套页面、如果服务端渲染资源获取失败  就要切换客户端渲染。
    2、ssr 缓存 对于多用户访问 相同的部分只渲染一次 不同的用户信息重新获取。
    3、更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。

  跨域之cors：
    1、对于主域下不同子域 资源访问 cookie 带不过去的跨域问题
      Access-Control-Allow-Origin
      Access-Control-Allow-Headers
    2、简单请求、复杂请求（options 预检）

  local file方案：
    1、采用 把资源打包 进app 用户访问时直接访问客户端本地文件
      这样的遇到的问题：
        1、域名问题 无法解决 本地资源域名跟主站不一致
        2、cookie 等问题
    2、优化方案采用 正常加载html 打包静态资源进app 方式 用户请求静态资源域名时进行拦截 校验是否有本地资源 如果没有就发起请求并进行缓存（同时删除过期资源）

简历
  突出自己做了什么 ，独立思考能力
  不要写太多 git vue全家桶之类的
  不要全写业务性的
  与UI UE 一起推动项目长流程项目简化

准备面试公司
  1.作业帮，每日优鲜，跟谁学，京东数科，小米
  2.好未来（学而思），猿辅导，京东方 
  3.头条，百度，滴滴，美团
HR question
  5、咱们招人的原因是什么
  6、咱们前端团队有多少人
  0、试用期 是否全薪
  1、社保等缴存比例
  2、多少薪
  3、房补饭补等
  4、上班时间、地点 是否双休
  
职业规划
  工程化、node、
离职原因
  在kid呆了快三年了， 想换一个环境
优缺点
  优点 工作认真
  缺点 不太会争取机会、 大胆改变 和 做技术储备 任务自然会分配给你
工作遇到的问题  如何解决的
  0、页面返回后的刷新问题
    如果只需要监听到这个事件 app内使用 app提供的pageshow方法
    如果刷新这个页面 使用worker 特性使页面没有cache 达到刷新的目的
  1、课程详情取消约课 500 日志大量飙升
      公司更换 cdn 供应商 供应商对500 的请求策略有8次重试造成
  2、安全组发现供需接口漏洞  xss 攻击修改 body
      网关使用Parameter 校验一家人  而供需组使用body 但是只校验了 操作人和学生的关系 没有token校验。
  3、ios 上自动执行focus()无法唤起键盘  非用户点击权限不够
      在用户点击搜索时隐藏一个input在按钮上 这样可以获得用户点击权限 成功唤起键盘
      该方法比较hack
最近在研究什么
  研究了一下 rem和px那个好   snowpack / vite  vue 3.0  http3.0

作业帮技术岗***
MVVM框架的理解 *****没答上来
vue router  history 和 hash 模式的区别
vue 组件懒加载 加载过的不再重复加载
首页白屏时间 缩短
对 哪些 webpack  plugin 有深入研究
this 的理解 感觉答的不太好 需要重新组织语言
event loop 需要重新组织语言  先讲异步同步 再讲 微任务宏任务
作业帮业务岗****
在  data 中实现一个 数据对象 不需要变更 不需要被监听？？？
3面 leader 2面官还可以（离地铁挺近）其他一般  期望30k 实际未回复

跟谁学面试*****
用户增长 中台 双休 早9点晚9点 团队12人 leader注重团队分享
http 缓存
http2.0 多路复用 和 1.1 的区别 输出格式是什么
node 是否熟悉
node eventLoop
async await 混合 promise 考察
手写 多请求限制最大并发 函数
vue router 懒加载 原理
module 语法 和 commonJS 区别 执行时机 / 引入的是否是动态
正方形 对角线实现  after / 渐变色
vue 3.0 新特性
nginx 配置是否了解
二面**
拥塞控制
options 请求
vue 新特性 实现原理
如何实现ui组件单元测试 覆盖不同手机型号、不同状态
webpack  优化
二分法快排  时间复杂度
babel 实现过程 字符串转ES6抽象语法树 转 ES5抽象语法树 转字符串输出 API 用 polyfill


新东方*****
集团IT部****
产品技术中心***


好未来****




CommonJS AMD Module
  http://javascript.ruanyifeng.com/nodejs/module.html
  http://es6.ruanyifeng.com/#docs/module
  CommonJS 规范 运用于node js 每个文件都是模块使用时加载 require 时会读取 module.exports 属性
    所有代码都运行在模块作用域，不会污染全局作用域。
    模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
    模块加载的顺序，按照其在代码中出现的顺序。

    加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式。
    module {
      id: 模块的识别符，通常是带有绝对路径的模块文件名。
      filename: 模块的文件名，带有绝对路径。
      loaded: 返回一个布尔值，表示模块是否已经完成加载。
      parent: 返回一个对象，表示调用该模块的模块。
      children: 返回一个数组，表示该模块要用到的其他模块。
      exports 表示模块对外输出的值。
    }
    每个模块内部会直接写入 exports 对象等同于 var exports = module.exports;
      (注意事项 不能直接对 exports 赋值；如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。)
    require 读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。
      对于对此require同一模块 不会重新加载 输出的是缓存 -> require.cache 
      如果脚本/home/user/projects/foo.js执行了require('bar.js')命令，Node会依次搜索以下文件。
        /usr/local/lib/node/bar.js
        /home/user/projects/node_modules/bar.js
        /home/user/node_modules/bar.js
        /home/node_modules/bar.js
        /node_modules/bar.js
      这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。
  AMD 规范 运用于浏览器环境
    AMD规范则是非同步加载模块，允许指定回调函数。
    define 方法定义模块 也可以兼容 CommonJS 规范
  Module 语法
    ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。 export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
    export
      命令规定的是对外的接口 不能输出值或代表值的变量包括fn class 等.
      语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。
      export 可以位于模块任何位置 但必须在模块顶层  不能在块级作用域
        let m = 1
        export m  //报错
        export { m }
        export { m as ma}
        export var m = 1;
        function a() {}
        export a  //报错
    import
      命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块对外接口的名称相同。或者使用as关键字。
      命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
      命令具有提升效果，会提升到整个模块的头部，首先执行。(命令是编译阶段执行的，在代码运行之前。)
      命令是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。
        //main.js
        export let name = 'abc' 
        import { name } from './main.js'
        import { name as nameUSA } from './main.js'
      语句会执行所加载的模块，因此可以有下面的写法。
        import 'lodash'; //不输入任何信息 只执行模块
      如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。
      整体加载，即用星号（*）指定一个对象
        //circle.js
        export function a(){}
        export function b(){}
        import * as circle from './circle';
        circle.a()
        circle.b()
        circle.a = 5 //报错 不允许对输出接口改写
    export default
      输出的是一个变量不是一个接口，实质是把输出的值赋值给 default（输出变量、fn、class）
      使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。
      为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出
        // export-default.js
        export default function () {
          console.log('foo');
        }
        import customName from './export-default';
        customName()

      export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。
        // modules.js
        function add(x, y) {
          return x * y;
        }
        export {add as default};
        // 等同于
        export default add;

        // app.js
        import { default as foo } from 'modules';
        // 等同于
        import foo from 'modules';
      可以和import 同时使用
        //lodash.js
        export default function (obj) {}
        export function each(obj, iterator, context) {}
        export { each as forEach };
        import _, { each, forEach } from 'lodash';
    export 与 import 的复合写法
      如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
      但需要注意的是，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和bar。
        export { foo, bar } from 'my_module';
        // 可以简单理解为
        import { foo, bar } from 'my_module';
        export { foo, bar };
        // export default
        export { default } from 'foo';






S 95≤得分≤100
  工作成果显著超出目标预期/岗位要求，有重大突破或创新

A 90≤得分＜95
  工作成果均超出目标预期/岗位要求，有亮点

B+ 85≤得分<90
  工作成果整体达标，有部分超出目标预期/岗位要求，有亮点
B 75≤得分<85
  工作成果整体达标，完全达到目标预期/岗位要求
B- 70≤得分<75
  工作成果整体达标，有部分达到目标预期/岗位要求，需要提高

C 60≤得分<70
  工作成果未达到目标预期/岗位要求，存在一些差距，存在一定改进空间
D 0≤得分<60
  工作成果未达到目标预期/岗位要求，存在明显差距