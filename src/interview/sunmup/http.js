/**
 * tcp/ip 三次握手四次握手 https://zhuanlan.zhihu.com/p/141396896?utm_source=wechat_session&utm_medium=social&utm_oi=751382926662320128
 * 什么是http https://zhuanlan.zhihu.com/p/102237039?utm_source=wechat_session&utm_medium=social&utm_oi=751382926662320128
 * url输入地址栏到加载出来页面发生了什么？http://www.dailichun.com/2018/03/12/whenyouenteraurl.html
*/

export default {
  title: '网络协议http',
  name: '', // 暂未使用保留字段
  content: [
    {
      title: '计算机网络体系结构',
      jsCode: ``,
      desc: [
        '在计算机网络的基本概念中，分层次的体系结构是最基本的。计算机网络体系结构的抽象概念较多，在学习时要多思考。这些概念对后面的学习很有帮助。',
      ],
    },
    {
      title: '网络协议是什么？',
      jsCode: ``,
      desc: [
        '在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。',
      ],
    },
    {
      title: '为什么要对网络协议分层？',
      jsCode: ``,
      desc: [
        '简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。',
        '灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。',
        '易于实现和维护。',
        '促进标准化工作。分开后，每层功能可以相对简单地被描述。',
        '网络协议分层的缺点： 功能可能出现在多个层里，产生了额外开销。',
      ],
    },
    {
      title: 'TCP/IP协议族',
      jsCode: ``,
      desc: [
        '四层协议，五层协议和七层协议的关系如下：  \
        <br>&nbsp;&nbsp; TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网络层(IP层解决不同网络的互连问题)、网络接口层。 \
        <br>&nbsp;&nbsp; 五层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层。 \
        <br>&nbsp;&nbsp; OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。 \
        <br>&nbsp;&nbsp; 注：五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。',
        'TCP 传输分为：连接 传输数据 关闭; 三次握手用于建立连接， 四次挥手用于关闭连接。',
        '三次握手: （A代表 客户端，B代表 服务端）\
        <br>&nbsp;&nbsp; 1.首先 A发送一封信给B，B收到信知道 A的发件能力和B的收件能力是可以的。 \
        <br>&nbsp;&nbsp; 2.B发送一份信给A，A收到知道 B的发件能力和A的收件能力是可以的。\
        <br>&nbsp;&nbsp; 3.但是B还不知道自己的发件能力是不是可以，所以A要发信告诉B收件成功了。B收到后就知道AB的收发件能力都是OK的 连接就建立了。',
        '四次挥手：（A代表 客户端，B代表 服务端） \
        <br>&nbsp;&nbsp; 1.当A发送完数据时，发一个信给B，告诉B想关闭通道。（此时A不能发送数据，但是可以接受数据） \
        <br>&nbsp;&nbsp; 2.B收到后 回复A一个确认信，表示知道了。（此时B还有数据没有发送完就会继续发送，处于等待关闭状态） \
        <br>&nbsp;&nbsp; 3.B发送完数据后，发一个信给A，告诉A想关闭通道。 \
        <br>&nbsp;&nbsp; 4.A收到后，像B发一个确认信，B收到后立即关闭TCP连接，A则要等2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。因此服务端结束TCP比客户端早。 \
        ',
      ],
    },
    {
      title: 'HTTP / HTTPS status',
      jsCode: ``,
      desc: [
        'HTTP全称为Hyper Text Transfer Protocol，中文翻译为超文本传输协议，目的是保证浏览器与服务器之间的通信。HTTP的工作方式是客户端与服务器之间的请求-应答协议。',
        '协商缓存（304）, 第一次请求200，缓存内容，第二次请求查询是否过期/有新的内容，没有返回304（只有header），有了200',
        '502 网关出错 是已经和服务端建立了连接 但是超时了。',
        '504 网关超时 是未和服务端建立连接 超时。',
      ],
      img: [
        '<img src="' + require('../img/http.jpg') + '" />',
        '<img src="' + require('../img/httpcode.jpg') + '" />',
        '<img src="' + require('../img/httpcode3xx.jpg') + '" />',
        '<img src="' + require('../img/httpcode5xx.jpg') + '" />',
      ]
    },
    {
      title: 'HTTP 是什么？',
      desc: [
        '超文本传输协议：超文本指 文字图片视频音频等，HTTP 是一个在计算机世界里专门在端到端之间传输超文本数据的约定和规范',
        'HTTP 是应用层协议，主要由 header + body 组成。',
        '默认端口HTTP为80，HTTPS为443',
        'HTTP 优点：是简单、灵活、易扩展、无状态、应用广、环境成熟。缺点：无状态 所以需要cookie，明文传输(报文部分)不够安全可以被监听和修改，性能虽然不差但是已经不能完全适应现在的互联网需求。',
        'HTTP 请求头 *******',
        'Cache-Control: \
        <br>&nbsp;&nbsp; no-cache（表示 不要缓存过期的资源，并不是不缓存。目的是防止缓存服务器返回过期的资源。） \
        <br>&nbsp;&nbsp; no-store（表示 不缓存）\
        <br>&nbsp;&nbsp; max-age=60（单位秒；代表资源保存为缓存的最长时间。值为0 缓存服务器会把请求给源服务器）',
        'Connection:  \
        <br>&nbsp;&nbsp; close（表示不保持连接，一次事务（一次三次握手和四次挥手）完成后关闭网络连接） \
        <br>&nbsp;&nbsp; keep-alive（持久性连接，即一次事务完成后不关闭网络连接）',
        'Keep-Alive: timeout=5, max=997。 表示的是 Connection 非持续连接的存活时间. \
        <br>&nbsp;&nbsp; timeout：指示空闲连接必须保持打开状态的最短时间（以秒为单位）。 \
        <br>&nbsp;&nbsp; max：指示在关闭连接之前可以在此连接上发送的最大请求数。',
        'Host: \
        <br>&nbsp;&nbsp; Host: www.baidu.com 指明了服务器的域名（比如 单台服务器分配多个域名），以及端口号 \
        <br>&nbsp;&nbsp; 在HTTP1.1规范内 hots是唯一一个必须被包含在请求内的首部字段 ',
        '内容协商：服务器驱动 / 客户端驱动 / 透明协商 \
        <br>&nbsp;&nbsp; Accept 接受请求 HTTP 标头会通告客户端其能够理解的 MIME(描述消息内容类型的因特网标准) 类型。文本(text/html、text/plain、text/css、application/xhtml+xml、application/xml)、图片(image/jpeg、image/gif、image/png)、视频(video/mpeg、video/quicktime)、二进制(application/octet-stream、application/zip) 。application/xml;q=0.9 q(表示权重，这是一个整体，默认1.0)\
        <br>&nbsp;&nbsp; Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。按q排权重 （en-US,en;q=0.5）',
      ]
    },
    {
      title: 'HTTP2',
      jsCode: ``,
      desc: [
        'HTTP2 可以提高了网页的性能。',
        '在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome 下一般是六个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。',
        'HTTP2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。',
        'HTTP2 中每个请求都被拆分成多个frame 通过一个 TCP 连接同时传输，这样即使一个请求被阻塞。也不会影响其他的请求。',
        'HTTP协议2及2以下是纯TCP, HTTP3是可以走基于UDP的QUIC协议的',
        '多路复用',
        '首部压缩（http头部压缩，减少体积）',
        '二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）',
        '服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）',
        '请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）',
      ],
    },
    {
      title: 'HTTP3',
      jsCode: ``,
      desc: [
        'HTTP3是基于UDP的QUIC协议的',
      ],
    },
    {
      title: 'HTTP的8种请求方法',
      desc: [
        'GET 获取资源，GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；',
        'POST 传输实体，虽然 GET 方法也可以传输主体信息，但是便于区分，我们一般不用 GET 传输实体信息，反而使用 POST 传输实体信息，',
        'PUT 传输文件，PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但是，鉴于 HTTP 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 W eb 网站不使用该方法。若配合 W eb 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。',
        'HEAD 获得响应首部，HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。',
        'DELETE 删除文件，DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。',
        'OPTIONS 询问支持的方法，OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。',
        'TRACE 追踪路径，TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。',
        'CONNECT 要求用隧道协议连接代理，CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输',
      ],
      img: [
        '<img src="' + require('../img/http1.0-http1.1-methods.jpg') + '" />',
      ]
    },
    {
      title: 'GET 和 POST区别',
      jsCode: ``,
      desc: [
        '说道GET和POST，就不得不提HTTP协议，因为浏览器和服务器的交互是通过HTTP协议执行的，而GET和POST也是HTTP协议中的两种方法。',
        '1.Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 但是这种做法也不时绝对的，大部分人的做法也是按照上面的说法来的，但是也可以在get请求加上 request body，给 post请求带上 URL 参数。',
        '2.Get请求提交的url中的数据最多只能是2048字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。Post请求则没有大小限制。',
        '3.Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。',
        '4.Get执行效率却比Post方法好。Get是form提交的默认方法。',
        '<span style="color: red">5.GET产生一个TCP数据包；POST产生两个TCP数据包。(这个被证明并不正确，只是个别框架在实现时做了先发header 后发body的事，跟http post无关)</span>',
        '对于 GET和POST 请求，浏览器会把http header和data/ body一并发送出去，服务器响应200（返回数据）；',
      ],
    },
    {
      title: 'TCP',
      desc: [
        'TCP 拥塞控制 为了避免过多数据涌入网络，使网络超出负荷。\
        <br>&nbsp;&nbsp; 1.慢启动：发送方向接收方发送 1 个单位的数据，对方确认收到后 发送 2 个单位，4个， 8个指数递增。这个过程是在不断试探网络的拥塞程度，超出阈值则会导致网络拥塞。 \
        <br>&nbsp;&nbsp; 2.拥塞避免：指数增长的数据发送不能是无限的，达到慢启动阈值之后，指数增长（爆炸增长）变为线性增长（成倍增长）。 \
        <br>&nbsp;&nbsp; 3.快慢重传：发送方每次发送都会设置一个超时计时器，超时后认为丢失，需要重发。 \
        <br>&nbsp;&nbsp; 4.快速恢复：在快慢重传的基础上，发送方重发数据时，也会启动一个超时计时器，如果收到确认消息则进入拥塞避免阶段，如果仍然超时，则回到慢启动阶段。 ',
      ]
    },
    {
      title: 'HTTP 缓存',
      desc: [
        // http://www.dailichun.com/2018/03/12/whenyouenteraurl.html
        '强缓存（200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求',
        '协商缓存（304）时，浏览器会向服务端发起http请求 通过Etag进行文件过期校验，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存',
        '对于协商缓存，使用Ctrl + F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）',
        '',
        '',
        '',
      ],
      img: [
        '<img src="' + require('../img/http_cache.png') + '" />',
      ]
    },
    {
      title: 'WAF',
      desc: [
        'WAF 是一种 Web 应用程序防护系统（Web Application Firewall，简称 WAF）。',
        '它是一种通过执行一系列针对HTTP / HTTPS的安全策略来专门为Web应用提供保护的一款产品，它是应用层面的防火墙，专门检测 HTTP 流量，是防护 Web 应用的安全技术。',
        'WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。',
      ]
    },
    {
      title: '非对称加密',
      jsCode: ``,
      desc: [
        '非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)',
        '公开密钥和私有密钥是一对  \
        <br>&nbsp;&nbsp;>>  如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。  \
        <br>&nbsp;&nbsp;>>  如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。  \
        <br>&nbsp;&nbsp;>>  因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。',
        '1.A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥',
        '2.A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。',
        '3.A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。',
        '4.A将这个消息发给B（已经用B的公钥加密消息）。',
        '5.B收到这个消息后，B用自己的私钥解密A的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥',
        '与对称加密算法的对比  \
        <br>&nbsp;&nbsp;>>  优点：其安全性更好，对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。  \
        <br>&nbsp;&nbsp;>>  缺点：非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。',
        '<br>&nbsp;&nbsp;>>  ',
      ],
    },
    {
      title: 'RSA 算法（最为广泛应用的非对称加密算法）',
      jsCode: ``,
      desc: [
        '这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。',
        '原理是 通过两个质数乘积很难算出两个质数的值，数值越大越难算。',
        '1.第一步，随机选择两个不相等的质数p和q。(exp: 61, 53; 越大越不容易被破解)',
        '2.第二步，计算p和q的乘积n。(n = p * q; 3233; 3233写成二进制是110010100001，一共有12位。 RSA密钥一般是1024位。)',
        '3.第三步，计算n的欧拉函数φ(n)。(φ(n) = (p-1)(q-1); 3120)',
        '4.第四步，随机选择一个整数e，条件是1< e < φ(n)，且e与φ(n) 互质。(17)',
        '5.第五步，计算e对于φ(n)的模反元素d。',
        '共有 p / q / n / φ(n) / e / d 6个值 其中(n, e)组成公钥，(n, d)组成私钥，想要破解私钥就要计算出d 而d需要φ(n) 也就是需要p / q 所以很难被破解',
        '用原始数据m 通过公钥 和 me ≡ c (mod n) 计算出被加密的c',
        '收到后c 通过私钥 和 cd ≡ m (mod n) 计算出原始数据m'
      ],
    },
    // {
    //   title: '',
    //   jsCode: ``,
    //   desc: [
    //     '<br>&nbsp;&nbsp;>>  ',
    //   ],
    //   img: []
    // },
  ]
}